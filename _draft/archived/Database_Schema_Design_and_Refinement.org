#+TITLE: 数据库模型设计与优化

#+OPTIONS: ^:nil

#+PROPERTY: header-args :exports both :pretty :eval never-export
#+PROPERTY: header-args:http+ :host api.btclass.net :curl -b bt.cookie -c bt.cookie :wrap "SRC json"
#+PROPERTY: header-args:sql+ :engine mysql :dbhost 120.76.213.19 :database btclass :dbuser developer :dbpassword developer123456 :cmdline --protocol=tcp

#+REVEAL: split
#+REVEAL_HLEVEL: 2
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+REVEAL_TRANS: page
#+REVEAL_THEME: moon

数据库模型的设计通常来说是编写代码的第一步。一个健壮的数据库模型可以为代码的编写打下了良好的基础，是整个代码编写过程中至为关键的一步。关系数据库诞生以来，科学界和工业界都为此作出了大量的研究，已经有了一些比较通用的方法。

*** 业务建模
    当项目从无到有的时候，我们首先要解决的是要创建什么模型，即创建哪些表的问题。这时候我们可以借助一些图示化的分析方法，对需求进行拆解，理清项目的重要概念，并用草图的方式勾勒出概念中的重要关联，形成对项目的总体把握。数据库建模之前通常需要对业务进行分析建模，比较常用的方法是领域模型建模。

**** 领域模型简介
     如图所示，领域模形是对领域内的概念类和现实世界对对象的可视化表示。

     file:image/domain-model-demo.png

     领域模型作为可视化字典，项目中所有重要的概念都应该可以从中找到自己的位置，是面向对象分析的经典方法。主要包含下三点。

     - 概念
     - 关联
     - 属性

     简单地理解，概念通常映射到数据库的表，属性是各个表的表头，至于关系，我们看一下 ER 图。
**** ER 图

     ER 图，即实体关系图。领域模型强调的对业务的分析，虽然许多概念可以拿到表中，但需要进一步的设计。ER 图是一种比较简单而有效的方法。ER 图认为数据库中的表可以分为两类，一种是实体表，如下表的方形框，另一种是关系表，如下表的菱形框。还有属性用椭圆框表示。此外还可以表示整体性约束和唯一性约束。

     下图映射到数据库中，我们会有包含 ssn, name, lot 的员工表，有一个包含 did, dname, budge 的部门表。还有一个 manages 表包含员工的 ssn, 部门的 did, 和一个 since 时间戳，表示该员工 since 某时刻起管理着这个部门。works_in 表类似。

    file:image/er-demo.png

*** Normal Form （范式)
    经由对业务的分析和对应的设计，我们已经可以得到模型的设计了。是不是可以开始进行业务代码的编写了呢？不尽然，这时候的表结构往往是比较粗糙的。关系数据库的研究者为数据库重构作了大量基础性的研究，使数据库重构有扎实的理论基础。只要按规范操作，基本都可以达到理想的设计。以下的例子大多来源于一个知乎高票回答： [[https://www.zhihu.com/question/24696366/answer/29189700][解释一下关系数据库的第一第二第三范式？]]

    首先，什么是范式，即标准形式呢？我们可以借助两个数学的例子来看一下。

    - 科学记数法
      - 1 * 10^6
      - 2 * 10^(-6)
    - 线性方程

      y = kx +b

    一个浮点数可以有多种表示方法，但是我们一般会用科学记数法。线性方程也有多种表示方法，但经常使用斜率交点式表示。它们是与其它表示方法等价的，而且与普通的表达方式相比，多出了对我们有用的特性。

    数据库的范式也有同样的特征。下面介绍几种范式。
**** 第一范式
     符合第一范式的每个属性都不可再分。简单地说，表的表头必须是拍平的。

     file:image/1nf-1.jpg

     file:image/1nf-2.jpg

     数据库管理系统不允许存在分层的表头，这是不是就是说只要是实际数据库出现的表一定符合第一范式呢？我们看几个比较复杂的情况。
***** json 类型
      从 5.7 版本开始，mysql 引进了 json 类型。在 5.7 之前，我们也可以用字符串化的方法将 json 存储到数据库中。json 数据实际上内含“表头”的。比如说我们可以在销售列存储 { quantity, price}。这显然区别于一般的数据。但是否是说就一定不符合第一范式呢？也不尽然，就看能不能将整个 json 作为一个整体。
***** 数组类型

      | Field          | Comment                | Type             |
      |----------------+------------------------+------------------|
      | id             | 课程 ID                | int(10) unsigned |
      | teacherIds     | 显示的课程教师 IDs     | text             |
      | assistantIds   | 显示的课程助教 IDs     | text             |
      | giftIds        | 赠送的课程 id          | varchar(1000)    |
      | combineCourses | 组合的课程(按字典排序) | text             |

      有时候我们会在数据库中用字符串存储数组类型的字段，取出时再解析出来。甚至有些数据库管理系统是支持数组类型的。但是如果考虑到联表，这显然是不便的。如上表中的 teacherIds。获取 teacher 的信息不能直接联表，而需要取出 teacherIds 然后解析，再查询 teacher 表。可以用 ER 图的关系表解决类似的问题。
***** 同一列中混杂不同信息

      | Field    | Comment                          | Type             |
      |----------+----------------------------------+------------------|
      | id       | 任务 ID                          | int(10) unsigned |
      | type     | 任务类型                         | varchar(255)     |
      | targetId | 类型 id,可以是课时 id,试卷 id 等 | int(10) unsigned |

      这和 json 和数组类型都比较类似。要符合第一范式，可以加上 task_lesson 和 task_testpaper 关系表。
**** 第二范式

***** 第一范式可能存在的问题
      符合第一范式的设计，仍然存在很多问题，对于下表：

      file:image/2nf-1.jpg

      1. 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次—— *数据冗余过大*
      2. 假如学校新建了一个系，但是暂时还没有招收任何学生（比如 3 月份就新建了，但要等到 8 月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 －－ *插入异常*
      3. 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。—— *删除异常*
      4. 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。—— *修改异常* 。

      在这里，我们引入函数依赖的概念。
***** 函数依赖

****** 函数依赖
       定义：若在一张表中，在属性（组）X 的值确定的情况下，必定能确定属性 Y 的值，那么称 Y 函数依赖于 X，或者 X 决定 Y。
       - 系名 -> 系主任
       - 学号 -> 系主任
       - （学号，课名） -> 分数

       为什么不直接叫依赖呢？因为除了函数依赖以外还有其它依赖，有兴趣的同学可以了解一下。

******* 完全函数依赖
        在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖。
******* 部份函数依赖
        假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X。
******* 传递函数依赖
        假如 Z 函数依赖于 Y，且 Y 函数依赖于 X，那么我们就称 Z 传递函数依赖于 X 。
******* 候选码（键），主属性
        假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。包含在任何一个码中的属性成为主属性。
****** 函数依赖图示

       file:image/2nf-2.jpg

       如图示，（学号，课名）是候选码（键），学号和课名都是主属性。（学号，课名）-> 分数 是完全函数依赖，除此所有的黑色箭头都是部分函数依赖。红色箭头表示传递函数依赖。
***** 第二范式
      第二范式在第一范式的基础上消除了非主属性对于码（键）的部份函数依赖。

      file:image/2nf-3.jpg

      file:image/2nf-4.jpg

      我们来看一下之前提到的问题是否得到解决。

      - 李小明转系到法律系只需要修改一次李小明对应的系的值即可。——有改进
      - 数据冗余是否减少了？学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进
      - 删除某个系中所有的学生记录该系的信息仍然全部丢失。——无改进
      - 插入一个尚无学生的新系的信息。因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进

**** 第三范式
     第三范式在第二范式的基础之上，消除了非主属性对于码的传递函数依赖。

     file:image/3nf-1.jpg

     file:image/3nf-2.jpg

     可以看到：

     - 删除某个系中所有的学生记录 该系的信息不会丢失。——有改进
     - 插入一个尚无学生的新系的信息。 因为系表与学生表目前是独立的两张表，所以不影响。——有改进
     - 数据冗余更加少了。——有改进

**** 其它范式
     除此以外还有 BCNF, 第四范式，第五范式等。BCNF 在第三范式的基础上消除了主属性对于码的部分函数依赖与传递函数依赖。第四范式，第五范式涉及到其它依赖。
*** Denormalization（反范式）
    数据库的范式和数学中的范式一样，和对应形式的其它模型是等价的，而且由上文可知，帮我们解决了一系列的数据库读写中的问题。然而它在实际推行中经常会遇到反对，通常的反对意见是这会导致信息的碎片化，需要更多的读写操作。用更低等级的范式取代更高等级的范式，甚至不采用任何范式，这称为反范式。

    这是不是值得的呢？我先说一下我对关系型数据库的理解。

    关系型数据库之所以称为关系型数据库，而不是表格数据库，是因为它存储的是一个个的真命题，而不仅仅是一个个的数据。对于单个表格，它表示在任何时刻，工号为 XXX 的工人，名字 xxx， 工龄 xxx 这样的信息都是正确的。数据库也存在各种各样的约束，以及外键等来确保数据的正确性和一致性。

    数据库的正确性和完整性是从用户操作到界面逻辑到业务代码的最后一条防线，如果不是性能瓶颈过大，完全无法克服，不该舍弃。

    - 对于一般的应用，远远达不到数据库管理系统所能支持的上限。如果是到达了瓶颈，更多的是我们优化得不够或者做得不够好了。
    - 即便是遇到了数据库性能的瓶颈，也不意味着就能够放弃数据的一致和正确。缺乏正确和一致的数据，大型的应用只会是更加脆弱。只是说把这一部分的工作移到了应用层，实际上更加耗费人力，提出了更高的要求。
    - 较好的方法是从一开始就遵从模式设计，坚持数据正确，遇到瓶颈之后再慢慢放开，在其它层面弥补。

    最后我们后面来说说如何克服信息碎片化和效率的问题。
*** 克服信息碎片化
**** 视图
     视图是数据库管理系统提供的虚拟表的机制，可以由基表定制我们需要的“模型”，借此将已经拆解的小表联合起来，解决信息碎片化问题。

     以下是 mysql 定义视图的方式。
     #+BEGIN_SRC sql
       CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) AS
       SELECT c1, c2 FROM t WHERE c3 > 100;
     #+END_SRC

     可以借由我们熟悉的 SELECT 语句得到虚拟表 v_merge 的数据。
     #+BEGIN_SRC sql
       SELECT * FROM v_merge;
     #+END_SRC

     DBMS 实际是用以下语句执行查询操作，和我们手动联表无异，但是这提供了一种抽象的机制，而且不会带来数据冗余造成及其造成的问题。
     #+BEGIN_SRC sql
       SELECT c1, c2 FROM t WHERE c3 > 100;
     #+END_SRC

     由一些视图甚至是可以更新，具体可以查看 mysql 的手册。遇到更复杂的情况，就要借助 ORM 的帮助。

**** ORM
     在引入 ORM 之前，我们先介绍一个很有实用价值的技巧。我们经常需要在数据库中存储树形结构。比较直观的方法是用一个属性存储父节点的 ID，称为邻接矩阵模型。这种方法简便直观，但是无力应付层数较深的数据，比如文件目录。这时可以实用路径枚举模型，如下图。

     | node | path  |
     |------+-------|
     | A    | a/    |
     | B    | a/b/  |
     | C    | a/c/  |
     | D    | a/c/d |
     | E    | a/c/e |
     | F    | a/c/f |

     有时我们甚至可以用嵌套集合模型，数据结构类似于 xml 的标签。

     file:image/nested-set-tree-1.png

     | Node | left | right |
     |------+------+-------|
     | A    |    1 |    12 |
     | B    |    2 |     3 |
     | C    |    4 |    11 |
     | D    |    5 |     6 |
     | E    |    7 |     8 |
     | f    |    9 |    10 |

     我们可以看到，同样的数据，可以有不同的表示方法。不仅仅是范式化会造成这种现象。我们需要一个中间层将业务逻辑与数据库模型隔离开。使得各自的改动尽可能造成小的影响。这就是ORM，即对象－关系映射。这里的 ORM 不是指具体的某个实现，而是这个中间层的统称。业务逻辑所操作的对象应该来自与这个中间层，与数据库实现松耦合。

     实际的应用中，我们会发现，很多模型都有类似的方法，每种语言都有不少第三方的 ORM 库。它们一般有以下功能。
     - 实用方法

       如对 SQL 查询语句的包装。

     - 自定义方法

       我们可以自定义方法，自己编写 SQL 语句实现自定义功能。

     - 虚拟属性

       一些可以计算属性可以预先定义。如日期格式的转化。

     - 软删除与乐观锁的实现

       这是在 ORM 层面对数据库功能的补充。

**** 外部缓存
     值得一提的是，redis 等外部缓存在今天也得到了广泛的应用，对传统的关系数据库起到了很大的辅助作用。很多 ORM 也利用了 redis 等机制加速查询。
*** 物理设计与读写效率
    数据库的性能提升是一个很庞大的课题，在这里仅围绕 B+ 树即 mysql innodb 的基本数据结构对数据库的索引做简单介绍。
**** 磁盘特性

     file:image/disk-structure.png

     传统的磁盘在今天仍然是数据库等大容量存储的主要媒介，它的主要特征可以归纳为一下三点。
     - 读取很慢，而且是一块一块（一页一页）地读的
     - 连续读比随机读快得多
     - 频繁读取的页是有缓存的
**** B+ 树

     file:image/B-tree-1.png

     file:image/B-tree-2.png

     以上两图表示的是一个 B+ 树插入 8* 的过程。B+ 树是平衡树的一种，一个节点代表一个页面，典型大小是 4K，一般正好是磁盘一次读写的大小。叶子节点存放的是键值对。Innodb 既用它来存放表数据，也用它来存放索引。当一个节点数据写满时，再插入新的数据，会导致节点分裂，甚至形成新的一层。但是一个非叶子节点容量达4K，一般可存1K行，三层数据可达1K x 1K x 1K = 1G. 四层可达 1T。可见 B+ 树兼有容量大，存取快的特点。

     当 B+ 树表示的是表数据时，键值对是<主键，数据行>, 非叶子节点是主键树。当 B+ 树表示的是索引树时，键值对是<索引，主键>. innodb 先用索引树找到主键，再用主键找对应的数据。

     通常来讲，如果要加速一个查询，建立索引是最简单便捷的办法。对于外键，唯一性约束，索引都是必须的。对于 B+ 树数据结构的深入理解，可以帮助我们改善索引。下面举两个例子。
**** 聚簇索引与主键
     在设计数据库表表头时，我们经常会使用无实际意义的递增数字作为主键。这种做法的好处在于新的数据一定会插入B+树的尾部，避免乱序插入，造成大量分裂，造成新建数据速度变慢。但是，从另外一方面讲，主键索引如果有实际的意义，可以避免新增一个索引。非主键索引往往需要经过查询主键这一步才能都到实际数据，读取性能也不如主键索引。如果是多读少写的数据，可以考虑使用有实际意义的主键。
**** 复合键索引
     索引并不是越多越好。插入新的数据，会造成索引树的分裂。索引越多，分裂造成的写延迟越大。对于复合键索引，可以避免一些冗余索引。

      | alpha | beta | theta |
      |-------+------+-------|
      | a     |      |       |
      | a     | b    |       |
      | a     | c    | b     |
      | b     | b    | c     |
      | b     | c    | a     |

      我们把上表当成一个小型的字典，记为(alpha, beta, theta).

      可以看到，它对以下键值是顺序的
      - (alpha)
      - (alpha, beta)
      - (alpha, beta, theta)

      对以下键值不是顺序的
      - (beta)
      - (beta, theta)
      - (theta)
      也就是说，一旦建立了(alpha, beta, theta)索引，(alpha), (alpha, beta)索引都是不必要的。
*** 参考
    - [[https://www.zhihu.com/question/24696366/answer/29189700][解释一下关系数据库的第一第二第三范式？]]
    - C.J.Date 2012 Database Design & Relational Theory
    - Larman 2003 UML 模式与应用
    - 罗摩克里希纳 2003 数据库管理系统原理与设计
    - Joe Celko 2013 Advanced SQL Programming
